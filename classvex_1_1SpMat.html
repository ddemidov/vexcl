<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>VexCL: vex::SpMat&lt; val_t, col_t, idx_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="gh.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">VexCL
   </div>
   <div id="projectbrief">C++ vector expression template library for OpenCL/CUDA</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevex.html">vex</a></li><li class="navelem"><a class="el" href="classvex_1_1SpMat.html">SpMat</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classvex_1_1SpMat-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vex::SpMat&lt; val_t, col_t, idx_t &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Sparse matrix in hybrid ELL-CSR format.  
 <a href="classvex_1_1SpMat.html#details">More...</a></p>

<p><code>#include &lt;spmat.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1bceb8e60e12c147076f80ef2ec0dd8e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bceb8e60e12c147076f80ef2ec0dd8e"></a>
typedef val_t&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:a1bceb8e60e12c147076f80ef2ec0dd8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59919e9a79cf2fb69e48a03f4429c383"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59919e9a79cf2fb69e48a03f4429c383"></a>
typedef cl_scalar_of&lt; val_t &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>scalar_type</b></td></tr>
<tr class="separator:a59919e9a79cf2fb69e48a03f4429c383"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9dcc260fadda1053d76baa7aca3692c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9dcc260fadda1053d76baa7aca3692c2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1SpMat.html#a9dcc260fadda1053d76baa7aca3692c2">SpMat</a> ()</td></tr>
<tr class="memdesc:a9dcc260fadda1053d76baa7aca3692c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor. <br /></td></tr>
<tr class="separator:a9dcc260fadda1053d76baa7aca3692c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97b79a5895ea713cee4a413551c1d41"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1SpMat.html#ae97b79a5895ea713cee4a413551c1d41">SpMat</a> (const std::vector&lt; <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &gt; &amp;queue, size_t n, size_t m, const idx_t *row, const col_t *col, const val_t *val)</td></tr>
<tr class="memdesc:ae97b79a5895ea713cee4a413551c1d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ae97b79a5895ea713cee4a413551c1d41">More...</a><br /></td></tr>
<tr class="separator:ae97b79a5895ea713cee4a413551c1d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3b691e6259530d43489215104d9d4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1SpMat.html#a8d3b691e6259530d43489215104d9d4a">apply</a> (const <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; val_t &gt; &amp;x, <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; val_t &gt; &amp;y, scalar_type alpha=1, bool append=false) const </td></tr>
<tr class="memdesc:a8d3b691e6259530d43489215104d9d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix-vector multiplication.  <a href="#a8d3b691e6259530d43489215104d9d4a">More...</a><br /></td></tr>
<tr class="separator:a8d3b691e6259530d43489215104d9d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024d177bdf1c0e1a58560b9de7881838"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a024d177bdf1c0e1a58560b9de7881838"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1SpMat.html#a024d177bdf1c0e1a58560b9de7881838">rows</a> () const </td></tr>
<tr class="memdesc:a024d177bdf1c0e1a58560b9de7881838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of rows. <br /></td></tr>
<tr class="separator:a024d177bdf1c0e1a58560b9de7881838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ca2c010f488b2f65784f1d7ab9b123"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36ca2c010f488b2f65784f1d7ab9b123"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1SpMat.html#a36ca2c010f488b2f65784f1d7ab9b123">cols</a> () const </td></tr>
<tr class="memdesc:a36ca2c010f488b2f65784f1d7ab9b123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of columns. <br /></td></tr>
<tr class="separator:a36ca2c010f488b2f65784f1d7ab9b123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23cdb6ebb8d614ba92b812e3f07de61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af23cdb6ebb8d614ba92b812e3f07de61"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1SpMat.html#af23cdb6ebb8d614ba92b812e3f07de61">nonzeros</a> () const </td></tr>
<tr class="memdesc:af23cdb6ebb8d614ba92b812e3f07de61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of non-zero entries. <br /></td></tr>
<tr class="separator:af23cdb6ebb8d614ba92b812e3f07de61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a16c9097d3b14d74e6aef947c7508dab9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16c9097d3b14d74e6aef947c7508dab9"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>inline_preamble</b> (backend::source_generator &amp;src, const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;queue, const std::string &amp;prm_name, detail::kernel_generator_state_ptr)</td></tr>
<tr class="separator:a16c9097d3b14d74e6aef947c7508dab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea3f840ff94b3cee97b42e1bdb4c138"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ea3f840ff94b3cee97b42e1bdb4c138"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>inline_expression</b> (backend::source_generator &amp;src, const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;queue, const std::string &amp;prm_name, detail::kernel_generator_state_ptr)</td></tr>
<tr class="separator:a2ea3f840ff94b3cee97b42e1bdb4c138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f87d505d7e3b6652afe22918448dacc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f87d505d7e3b6652afe22918448dacc"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>inline_parameters</b> (backend::source_generator &amp;src, const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;queue, const std::string &amp;prm_name, detail::kernel_generator_state_ptr)</td></tr>
<tr class="separator:a0f87d505d7e3b6652afe22918448dacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1006407849900291442de890eef703d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1006407849900291442de890eef703d"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>inline_arguments</b> (backend::kernel &amp;kernel, unsigned part, size_t, const <a class="el" href="classvex_1_1SpMat.html">SpMat</a> &amp;A, const <a class="el" href="classvex_1_1vector.html">vector</a>&lt; val_t &gt; &amp;x, detail::kernel_generator_state_ptr)</td></tr>
<tr class="separator:ac1006407849900291442de890eef703d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename val_t, typename col_t = size_t, typename idx_t = size_t&gt;<br />
class vex::SpMat&lt; val_t, col_t, idx_t &gt;</h3>

<p>Sparse matrix in hybrid ELL-CSR format. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae97b79a5895ea713cee4a413551c1d41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename val_t, typename col_t = size_t, typename idx_t = size_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvex_1_1SpMat.html">vex::SpMat</a>&lt; val_t, col_t, idx_t &gt;::<a class="el" href="classvex_1_1SpMat.html">SpMat</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const idx_t *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const col_t *&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const val_t *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Constructs GPU representation of the matrix. Input matrix is in CSR format. GPU matrix utilizes ELL format and is split equally across all compute devices. When there are more than one device, secondary queue can be used to perform transfer of ghost values across GPU boundaries in parallel with computation kernel. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>vector of queues. Each queue represents one compute device. </td></tr>
    <tr><td class="paramname">n</td><td>number of rows in the matrix. </td></tr>
    <tr><td class="paramname">m</td><td>number of cols in the matrix. </td></tr>
    <tr><td class="paramname">row</td><td>row index into col and val vectors. </td></tr>
    <tr><td class="paramname">col</td><td>column numbers of nonzero elements of the matrix. </td></tr>
    <tr><td class="paramname">val</td><td>values of nonzero elements of the matrix. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="namespacevex_1_1backend_1_1cuda.html#a26115fef08c8f8475271f821132b545b">vex::backend::cuda::duplicate_queue()</a>, <a class="el" href="namespacevex_1_1backend_1_1cuda.html#aa57c519ac45e9b247d19051f8b415dff">vex::backend::cuda::is_cpu()</a>, and <a class="el" href="namespacevex.html#ae08b03eaab6548720caf55e47f5cfc91">vex::partition()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8d3b691e6259530d43489215104d9d4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename val_t, typename col_t = size_t, typename idx_t = size_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvex_1_1SpMat.html">vex::SpMat</a>&lt; val_t, col_t, idx_t &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; val_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; val_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar_type&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>append</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix-vector multiplication. </p>
<p>Matrix vector multiplication ( <img class="formulaInl" alt="$y = \alpha Ax$" src="form_0.png"/> or <img class="formulaInl" alt="$y += \alpha Ax$" src="form_1.png"/>) is performed in parallel on all registered compute devices. Ghost values of x are transfered across GPU boundaries as needed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input vector. </td></tr>
    <tr><td class="paramname">y</td><td>output vector. </td></tr>
    <tr><td class="paramname">alpha</td><td>coefficient in front of matrix-vector product </td></tr>
    <tr><td class="paramname">append</td><td>if set, matrix-vector product is appended to y. Otherwise, y is replaced with matrix-vector product. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classvex_1_1vector.html#ad15856f00b1c4b80726e6f908260ef57">vex::vector&lt; T &gt;::begin()</a>, <a class="el" href="classvex_1_1SpMat.html#a36ca2c010f488b2f65784f1d7ab9b123">vex::SpMat&lt; val_t, col_t, idx_t &gt;::cols()</a>, <a class="el" href="namespacevex.html#aaa68b032f0d66695e3b3b6c5375e8cf6">vex::copy()</a>, <a class="el" href="classvex_1_1vector.html#a5169d2645c884403fa690d45c77552fa">vex::vector&lt; T &gt;::end()</a>, <a class="el" href="namespacevex.html#a1d8048e3bb5185ab018e9d0a0649ef0b">vex::permutation()</a>, and <a class="el" href="namespacevex_1_1backend_1_1cuda.html#aaf54a7c18c4e5f46191e50eaddf93014">vex::backend::cuda::select_context()</a>.</p>

<p>Referenced by <a class="el" href="namespacevex.html#ac74a209f956b87b8dc289aad5498a25c">vex::device_spmv_perf()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>vexcl/<a class="el" href="spmat_8hpp.html">spmat.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
