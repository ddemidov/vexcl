<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>VexCL: vex Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="gh.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">VexCL
   </div>
   <div id="projectbrief">C++ vector expression template library for OpenCL/CUDA</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">vex Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Vector expression template library for OpenCL.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacevex_1_1backend"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex_1_1backend.html">backend</a></td></tr>
<tr class="memdesc:namespacevex_1_1backend"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backend-specific functionality. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevex_1_1clogs"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex_1_1clogs.html">clogs</a></td></tr>
<tr class="memdesc:namespacevex_1_1clogs"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrappers for the clogs library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevex_1_1compute"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex_1_1compute.html">compute</a></td></tr>
<tr class="memdesc:namespacevex_1_1compute"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapping code for some of Boost.Compute algorithms. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevex_1_1constants"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex_1_1constants.html">constants</a></td></tr>
<tr class="memdesc:namespacevex_1_1constants"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mathematical constants. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevex_1_1fft"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex_1_1fft.html">fft</a></td></tr>
<tr class="memdesc:namespacevex_1_1fft"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast Fourier Transform. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevex_1_1Filter"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex_1_1Filter.html">Filter</a></td></tr>
<tr class="memdesc:namespacevex_1_1Filter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device filters. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevex_1_1generator"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex_1_1generator.html">generator</a></td></tr>
<tr class="memdesc:namespacevex_1_1generator"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classvex_1_1generator_1_1Kernel.html" title="Autogenerated kernel. ">Kernel</a> generation interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevex_1_1random"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex_1_1random.html">random</a></td></tr>
<tr class="memdesc:namespacevex_1_1random"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvex_1_1Random.html" title="A random generator. ">Random</a> generators. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1all__of.html">all_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor that checks if all elements in a vector expression are true.  <a href="classvex_1_1all__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1any__of.html">any_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor that checks if any element in a vector expression is true.  <a href="classvex_1_1any__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1Context.html">Context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">VexCL context holder.  <a href="classvex_1_1Context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1FFT.html">FFT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast Fourier Transform.  <a href="structvex_1_1FFT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1gather.html">gather</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers vector elements at specified indices.  <a href="classvex_1_1gather.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1greater.html">greater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object class for greater-than inequality comparison.  <a href="structvex_1_1greater.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1greater__equal.html">greater_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object class for greater-than-or-equal inequality comparison.  <a href="structvex_1_1greater__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1gslice.html">gslice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalized slice selector.  <a href="structvex_1_1gslice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1is__device__filter.html">is_device_filter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if type is a device filter.  <a href="structvex_1_1is__device__filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1is__multivector__expression.html">is_multivector_expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-filter for VexCL multivector expressions.  <a href="structvex_1_1is__multivector__expression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1is__vector__expression.html">is_vector_expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-filter for VexCL vector expressions.  <a href="structvex_1_1is__vector__expression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1less.html">less</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object class for less-than inequality comparison.  <a href="structvex_1_1less.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1less__equal.html">less_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object class for less-than-or-equal inequality comparison.  <a href="structvex_1_1less__equal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1MAX.html">MAX</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum element. Should be used as a template parameter for <a class="el" href="classvex_1_1Reductor.html" title="Parallel reduction of arbitrary expression. ">Reductor</a> class.  <a href="structvex_1_1MAX.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1mba.html">mba</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scattered data interpolation with multilevel B-Splines.  <a href="classvex_1_1mba.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1MIN.html">MIN</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum element. Should be used as a template parameter for <a class="el" href="classvex_1_1Reductor.html" title="Parallel reduction of arbitrary expression. ">Reductor</a> class.  <a href="structvex_1_1MIN.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1multivector.html">multivector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for several vex::vectors.  <a href="classvex_1_1multivector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1plus.html">plus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary function object class whose call returns the result of adding its two arguments.  <a href="structvex_1_1plus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1profiler.html">profiler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for gathering and printing OpenCL and Host profiling info.  <a href="classvex_1_1profiler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1Random.html">Random</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random generator.  <a href="structvex_1_1Random.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1RandomNormal.html">RandomNormal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns normal distributed random numbers.  <a href="structvex_1_1RandomNormal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1range.html">range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An index range for use with slicer class.  <a href="structvex_1_1range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1Reductor.html">Reductor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel reduction of arbitrary expression.  <a href="classvex_1_1Reductor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1slicer.html">slicer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slicing operator.  <a href="structvex_1_1slicer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1SpMat.html">SpMat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix in hybrid ELL-CSR format.  <a href="classvex_1_1SpMat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1SpMatCCSR.html">SpMatCCSR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix in CCSR format.  <a href="structvex_1_1SpMatCCSR.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1stencil.html">stencil</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stencil.  <a href="classvex_1_1stencil.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1StencilOperator.html">StencilOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined stencil operator.  <a href="classvex_1_1StencilOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1stopwatch.html">stopwatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stopwatch that computes the median and mean of individual timings.  <a href="classvex_1_1stopwatch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1SUM.html">SUM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Summation. Should be used as a template parameter for <a class="el" href="classvex_1_1Reductor.html" title="Parallel reduction of arbitrary expression. ">Reductor</a> class.  <a href="structvex_1_1SUM.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1SUM__Kahan.html">SUM_Kahan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compensated summation.  <a href="structvex_1_1SUM__Kahan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html">vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device vector.  <a href="classvex_1_1vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2f3700c5a3fd689cebd1c3301266b7ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a2f3700c5a3fd689cebd1c3301266b7ff">push_compile_options</a> (const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;q, const std::string &amp;str)</td></tr>
<tr class="memdesc:a2f3700c5a3fd689cebd1c3301266b7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set global compute kernel compilation options for a given device.  <a href="#a2f3700c5a3fd689cebd1c3301266b7ff">More...</a><br /></td></tr>
<tr class="separator:a2f3700c5a3fd689cebd1c3301266b7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07c402052137a80de67e1137f258341"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac07c402052137a80de67e1137f258341"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#ac07c402052137a80de67e1137f258341">pop_compile_options</a> (const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;q)</td></tr>
<tr class="memdesc:ac07c402052137a80de67e1137f258341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rolls back changes to compile options. <br /></td></tr>
<tr class="separator:ac07c402052137a80de67e1137f258341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16dc38863b68e8c2cd28a117044a3b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#aa16dc38863b68e8c2cd28a117044a3b6">push_program_header</a> (const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;q, const std::string &amp;str)</td></tr>
<tr class="memdesc:aa16dc38863b68e8c2cd28a117044a3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set global compute kernel header for a given device.  <a href="#aa16dc38863b68e8c2cd28a117044a3b6">More...</a><br /></td></tr>
<tr class="separator:aa16dc38863b68e8c2cd28a117044a3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5371f8233d7cfed97b68e3126e860e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f5371f8233d7cfed97b68e3126e860e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a1f5371f8233d7cfed97b68e3126e860e">pop_program_header</a> (const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;q)</td></tr>
<tr class="memdesc:a1f5371f8233d7cfed97b68e3126e860e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rolls back changes to compile options. <br /></td></tr>
<tr class="separator:a1f5371f8233d7cfed97b68e3126e860e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9db4bda4971c23090ce43eb9e578f65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9db4bda4971c23090ce43eb9e578f65"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#ab9db4bda4971c23090ce43eb9e578f65">push_compile_options</a> (const std::vector&lt; <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &gt; &amp;queue, const std::string &amp;str)</td></tr>
<tr class="memdesc:ab9db4bda4971c23090ce43eb9e578f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set global compute kernel compilation options for each device in queue list. <br /></td></tr>
<tr class="separator:ab9db4bda4971c23090ce43eb9e578f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87387b148e5f12d36cea89fdfb7a11cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87387b148e5f12d36cea89fdfb7a11cd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a87387b148e5f12d36cea89fdfb7a11cd">pop_compile_options</a> (const std::vector&lt; <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &gt; &amp;queue)</td></tr>
<tr class="memdesc:a87387b148e5f12d36cea89fdfb7a11cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rolls back changes to compile options for each device in queue list. <br /></td></tr>
<tr class="separator:a87387b148e5f12d36cea89fdfb7a11cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a560d2aca37d3493b5cdd4bd317e72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00a560d2aca37d3493b5cdd4bd317e72"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a00a560d2aca37d3493b5cdd4bd317e72">push_program_header</a> (const std::vector&lt; <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &gt; &amp;queue, const std::string &amp;str)</td></tr>
<tr class="memdesc:a00a560d2aca37d3493b5cdd4bd317e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set global OpenCL program header for each device in queue list. <br /></td></tr>
<tr class="separator:a00a560d2aca37d3493b5cdd4bd317e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d16252288166999a5494d04f35cf9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6d16252288166999a5494d04f35cf9c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#ae6d16252288166999a5494d04f35cf9c">pop_program_header</a> (const std::vector&lt; <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &gt; &amp;queue)</td></tr>
<tr class="memdesc:ae6d16252288166999a5494d04f35cf9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rolls back changes to compile options for each device in queue list. <br /></td></tr>
<tr class="separator:ae6d16252288166999a5494d04f35cf9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8327486578e0ab169174a502b8a7fe4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8327486578e0ab169174a502b8a7fe4"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#aa8327486578e0ab169174a502b8a7fe4">path_delim</a> ()</td></tr>
<tr class="memdesc:aa8327486578e0ab169174a502b8a7fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Path delimiter symbol. <br /></td></tr>
<tr class="separator:aa8327486578e0ab169174a502b8a7fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5ead15e3e07a03b02228d137548be7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f5ead15e3e07a03b02228d137548be7"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a0f5ead15e3e07a03b02228d137548be7">appdata_path</a> ()</td></tr>
<tr class="memdesc:a0f5ead15e3e07a03b02228d137548be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Path to appdata folder. <br /></td></tr>
<tr class="separator:a0f5ead15e3e07a03b02228d137548be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad813c378c0e17666ad73c9dd3ab504"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ad813c378c0e17666ad73c9dd3ab504"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a1ad813c378c0e17666ad73c9dd3ab504">program_binaries_path</a> (const std::string &amp;hash, bool create=false)</td></tr>
<tr class="memdesc:a1ad813c378c0e17666ad73c9dd3ab504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Path to cached binaries. <br /></td></tr>
<tr class="separator:a1ad813c378c0e17666ad73c9dd3ab504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dac744b63fbd08c03814bb6ab6ee81c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8dac744b63fbd08c03814bb6ab6ee81c"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a8dac744b63fbd08c03814bb6ab6ee81c">sha1</a> (const std::string &amp;src)</td></tr>
<tr class="memdesc:a8dac744b63fbd08c03814bb6ab6ee81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns SHA1 hash of the string parameter. <br /></td></tr>
<tr class="separator:a8dac744b63fbd08c03814bb6ab6ee81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af675beaf7e25b1b8ec56d17f0593bf5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af675beaf7e25b1b8ec56d17f0593bf5c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#af675beaf7e25b1b8ec56d17f0593bf5c">purge_caches</a> ()</td></tr>
<tr class="memdesc:af675beaf7e25b1b8ec56d17f0593bf5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears cached objects, allowing to cleanly release contexts. <br /></td></tr>
<tr class="separator:af675beaf7e25b1b8ec56d17f0593bf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a15b0db018d6ca06d90ead33370e7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65a15b0db018d6ca06d90ead33370e7b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a65a15b0db018d6ca06d90ead33370e7b">purge_caches</a> (const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;q)</td></tr>
<tr class="memdesc:a65a15b0db018d6ca06d90ead33370e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears cached objects, allowing to cleanly release contexts. <br /></td></tr>
<tr class="separator:a65a15b0db018d6ca06d90ead33370e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef70cbea2211bce647aa0a12cb3e88e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ef70cbea2211bce647aa0a12cb3e88e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a4ef70cbea2211bce647aa0a12cb3e88e">purge_caches</a> (const std::vector&lt; <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &gt; &amp;queue)</td></tr>
<tr class="memdesc:a4ef70cbea2211bce647aa0a12cb3e88e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears cached objects, allowing to cleanly release contexts. <br /></td></tr>
<tr class="separator:a4ef70cbea2211bce647aa0a12cb3e88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e99ed569f1fd1b476b84ce40960db91"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7e99ed569f1fd1b476b84ce40960db91"></a>
template&lt;typename T , class Expr &gt; </td></tr>
<tr class="memitem:a7e99ed569f1fd1b476b84ce40960db91"><td class="memTemplItemLeft" align="right" valign="top">expession::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a7e99ed569f1fd1b476b84ce40960db91">cast</a> (const Expr &amp;expr)</td></tr>
<tr class="memdesc:a7e99ed569f1fd1b476b84ce40960db91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast an expression to a given type. <br /></td></tr>
<tr class="separator:a7e99ed569f1fd1b476b84ce40960db91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f952de6aa067cc2e34ef16e91429e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78f952de6aa067cc2e34ef16e91429e7"></a>
const <a class="el" href="classvex_1_1Context.html">Context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a78f952de6aa067cc2e34ef16e91429e7">current_context</a> ()</td></tr>
<tr class="memdesc:a78f952de6aa067cc2e34ef16e91429e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the latest instance of <a class="el" href="classvex_1_1Context.html" title="VexCL context holder. ">vex::Context</a>. <br /></td></tr>
<tr class="separator:a78f952de6aa067cc2e34ef16e91429e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf35349b5accc05f96b291457f522acb"><td class="memItemLeft" align="right" valign="top">elem_index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#acf35349b5accc05f96b291457f522acb">element_index</a> (size_t offset=0, size_t length=0)</td></tr>
<tr class="memdesc:acf35349b5accc05f96b291457f522acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">When used in vector expression, returns current element index plus offset.  <a href="#acf35349b5accc05f96b291457f522acb">More...</a><br /></td></tr>
<tr class="separator:acf35349b5accc05f96b291457f522acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1228fa9f34fb59a5711ec93e2895b40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae1228fa9f34fb59a5711ec93e2895b40"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>abs_diff</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gae1228fa9f34fb59a5711ec93e2895b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga525c6279583a7f60aa3b89f20967365e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga525c6279583a7f60aa3b89f20967365e"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>acos</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga525c6279583a7f60aa3b89f20967365e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4fcd243edf6be7d6c465f6cbda24644"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab4fcd243edf6be7d6c465f6cbda24644"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>acosh</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gab4fcd243edf6be7d6c465f6cbda24644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee516d9143e39fee4e255081ae7be571"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaee516d9143e39fee4e255081ae7be571"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>acospi</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gaee516d9143e39fee4e255081ae7be571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4835eea02db47ab0c335de0cd990c452"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4835eea02db47ab0c335de0cd990c452"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>add_sat</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga4835eea02db47ab0c335de0cd990c452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf8972d7be7abefb5f234842ebb97deb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabf8972d7be7abefb5f234842ebb97deb"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>all</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gabf8972d7be7abefb5f234842ebb97deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc09ba3ab84dad21bd7b7f542efa3313"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabc09ba3ab84dad21bd7b7f542efa3313"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>any</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gabc09ba3ab84dad21bd7b7f542efa3313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6c897ef903f65e1d9c096c6aee03670"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab6c897ef903f65e1d9c096c6aee03670"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>asin</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gab6c897ef903f65e1d9c096c6aee03670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga519b3d94dbcdf1d3c930c8c96440e41a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga519b3d94dbcdf1d3c930c8c96440e41a"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>asinh</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga519b3d94dbcdf1d3c930c8c96440e41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6133750c6a2b95e7f5a75de9f0ba1aa0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6133750c6a2b95e7f5a75de9f0ba1aa0"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>asinpi</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga6133750c6a2b95e7f5a75de9f0ba1aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac87cb72a6b791e804eae9cf4aad94f9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac87cb72a6b791e804eae9cf4aad94f9b"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>atan</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gac87cb72a6b791e804eae9cf4aad94f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga416b327eb7dd0b8f4a24b5ecb4933bb8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga416b327eb7dd0b8f4a24b5ecb4933bb8"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>atan2</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga416b327eb7dd0b8f4a24b5ecb4933bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1961edc7c7f22c9765100bcb4ec2b79f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1961edc7c7f22c9765100bcb4ec2b79f"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>atan2pi</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga1961edc7c7f22c9765100bcb4ec2b79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1894bbb8f62a117daaa4ad52f7ec6556"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1894bbb8f62a117daaa4ad52f7ec6556"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>atanh</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga1894bbb8f62a117daaa4ad52f7ec6556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae152028b5291f8266f503fe1498b0844"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae152028b5291f8266f503fe1498b0844"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>atanpi</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gae152028b5291f8266f503fe1498b0844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeef2a9f916af24103f44f44c31c1966d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeef2a9f916af24103f44f44c31c1966d"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>bitselect</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gaeef2a9f916af24103f44f44c31c1966d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fb069504af0b637115b66d0a58f7c8c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7fb069504af0b637115b66d0a58f7c8c"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>cbrt</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga7fb069504af0b637115b66d0a58f7c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cc5b313a4dd0d81d49cb8a5037272a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5cc5b313a4dd0d81d49cb8a5037272a5"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>ceil</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga5cc5b313a4dd0d81d49cb8a5037272a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3d5e0cac51484a1a261f8b795e0f21a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf3d5e0cac51484a1a261f8b795e0f21a"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>clamp</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gaf3d5e0cac51484a1a261f8b795e0f21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61373303ca9a9eb58644db2ccf5185f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga61373303ca9a9eb58644db2ccf5185f5"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>clz</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga61373303ca9a9eb58644db2ccf5185f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaded809c673eaa9f678ff8e7df64903e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaded809c673eaa9f678ff8e7df64903e3"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>copysign</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gaded809c673eaa9f678ff8e7df64903e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07cbd2b736d025ae9352b3f4cb34a50a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga07cbd2b736d025ae9352b3f4cb34a50a"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>cos</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga07cbd2b736d025ae9352b3f4cb34a50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3de60dfc3158dd0b38dd0263829617a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab3de60dfc3158dd0b38dd0263829617a"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>cosh</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gab3de60dfc3158dd0b38dd0263829617a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga344fe959ad4a0a21096f29f0801e0d0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga344fe959ad4a0a21096f29f0801e0d0f"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>cospi</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga344fe959ad4a0a21096f29f0801e0d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6782e433551e987074e753be1a2f7db3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6782e433551e987074e753be1a2f7db3"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>cross</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga6782e433551e987074e753be1a2f7db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82194d203f0e23c6ceaf59d0f4004f69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga82194d203f0e23c6ceaf59d0f4004f69"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>degrees</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga82194d203f0e23c6ceaf59d0f4004f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57f1253c62e47e1fa809ff3c01f2b658"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga57f1253c62e47e1fa809ff3c01f2b658"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>distance</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga57f1253c62e47e1fa809ff3c01f2b658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4554dcb09b5783452d9d1fbf1395729b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4554dcb09b5783452d9d1fbf1395729b"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>dot</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga4554dcb09b5783452d9d1fbf1395729b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecab0bf620f4cb348c8f9c5cd381b921"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaecab0bf620f4cb348c8f9c5cd381b921"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>erf</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gaecab0bf620f4cb348c8f9c5cd381b921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d1ae8bee6a690e5cdb4fe5cd1712af6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4d1ae8bee6a690e5cdb4fe5cd1712af6"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>erfc</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga4d1ae8bee6a690e5cdb4fe5cd1712af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bad5ef8b2591b25a43525d43354394a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8bad5ef8b2591b25a43525d43354394a"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>exp</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga8bad5ef8b2591b25a43525d43354394a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca467900f0a89607dd3b11f10b4e8d0c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaca467900f0a89607dd3b11f10b4e8d0c"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>exp10</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gaca467900f0a89607dd3b11f10b4e8d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga645e49d0664d5d033af511ed078b64c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga645e49d0664d5d033af511ed078b64c1"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>exp2</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga645e49d0664d5d033af511ed078b64c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d4e6ce2d0baf7fecffb3a2186dde1df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3d4e6ce2d0baf7fecffb3a2186dde1df"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>expm1</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga3d4e6ce2d0baf7fecffb3a2186dde1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga744f2abd6e01fcf0b2cf0719ad7b1d4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga744f2abd6e01fcf0b2cf0719ad7b1d4b"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>fabs</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga744f2abd6e01fcf0b2cf0719ad7b1d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga426a81854218474655bd90b5851e7162"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga426a81854218474655bd90b5851e7162"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>fast_distance</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga426a81854218474655bd90b5851e7162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1692791313b53a6a9d53a0d62fa264d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1692791313b53a6a9d53a0d62fa264d0"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>fast_length</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga1692791313b53a6a9d53a0d62fa264d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98cd0320e8e97aaa1fffbb6474b25f34"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga98cd0320e8e97aaa1fffbb6474b25f34"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>fast_normalize</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga98cd0320e8e97aaa1fffbb6474b25f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c280b3254676e40594796dfe745261b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9c280b3254676e40594796dfe745261b"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>fdim</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga9c280b3254676e40594796dfe745261b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6e38149bd28ce6c56a6eae2fa66449f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae6e38149bd28ce6c56a6eae2fa66449f"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>floor</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gae6e38149bd28ce6c56a6eae2fa66449f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29d151f9e41c14aba5040fe09c942be8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga29d151f9e41c14aba5040fe09c942be8"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>fma</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga29d151f9e41c14aba5040fe09c942be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e2fdbbd0107d4ed497f7c68c60c0f09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6e2fdbbd0107d4ed497f7c68c60c0f09"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>fmax</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga6e2fdbbd0107d4ed497f7c68c60c0f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa10a7613dad742e6fde91f0fa30d9262"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa10a7613dad742e6fde91f0fa30d9262"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>fmin</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gaa10a7613dad742e6fde91f0fa30d9262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79fecfc82fa232cca4a4104f00ba49c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga79fecfc82fa232cca4a4104f00ba49c0"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>fmod</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga79fecfc82fa232cca4a4104f00ba49c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb5926335056eb3dc1d2ec22c8580ef4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadb5926335056eb3dc1d2ec22c8580ef4"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>fract</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gadb5926335056eb3dc1d2ec22c8580ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac77e0cf37602b4573e4f82f2f28d3546"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac77e0cf37602b4573e4f82f2f28d3546"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>frexp</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gac77e0cf37602b4573e4f82f2f28d3546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81389a2e129bc038421b7ebce052a962"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga81389a2e129bc038421b7ebce052a962"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>hadd</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga81389a2e129bc038421b7ebce052a962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9617a1044790575be3964080ce1c1be1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9617a1044790575be3964080ce1c1be1"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>hypot</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga9617a1044790575be3964080ce1c1be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f26865ce95e23fe6d205ef88ad7fe06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0f26865ce95e23fe6d205ef88ad7fe06"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>ilogb</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga0f26865ce95e23fe6d205ef88ad7fe06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga273d74140d89c4fa027403feb8f2549d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga273d74140d89c4fa027403feb8f2549d"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>isequal</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga273d74140d89c4fa027403feb8f2549d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga252707c3156eca0be4ed33c838ea275f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga252707c3156eca0be4ed33c838ea275f"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>isfinite</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga252707c3156eca0be4ed33c838ea275f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a585588435c1e649042c6818a26173c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3a585588435c1e649042c6818a26173c"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>isgreater</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga3a585588435c1e649042c6818a26173c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad8090cfce8fd6d7339ab5f87214d668"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaad8090cfce8fd6d7339ab5f87214d668"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>isgreaterequal</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gaad8090cfce8fd6d7339ab5f87214d668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12cdebf3de4bd36c0b69d97a5e669f36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga12cdebf3de4bd36c0b69d97a5e669f36"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>isinf</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga12cdebf3de4bd36c0b69d97a5e669f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eaf5ec97629434a133da5d8dc519ac8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6eaf5ec97629434a133da5d8dc519ac8"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>isless</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga6eaf5ec97629434a133da5d8dc519ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6169a653ee31c50f035c0d96b0ba882f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6169a653ee31c50f035c0d96b0ba882f"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>islessequal</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga6169a653ee31c50f035c0d96b0ba882f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadebb0daf9d59267a1d144cc432f9abda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadebb0daf9d59267a1d144cc432f9abda"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>islessgreater</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gadebb0daf9d59267a1d144cc432f9abda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18608f7c4c13a12cd4d3bd2223e7fcd2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga18608f7c4c13a12cd4d3bd2223e7fcd2"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>isnan</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga18608f7c4c13a12cd4d3bd2223e7fcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b335b34346008fb4df946d9e57bb5ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6b335b34346008fb4df946d9e57bb5ff"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>isnormal</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga6b335b34346008fb4df946d9e57bb5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92324ac8d9a04dd4f20658ce709c5071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga92324ac8d9a04dd4f20658ce709c5071"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>isnotequal</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga92324ac8d9a04dd4f20658ce709c5071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga933baf8765a1dbf87940f38e311f54ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga933baf8765a1dbf87940f38e311f54ee"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>isordered</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga933baf8765a1dbf87940f38e311f54ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2be5f7fbfeb00dc7ff8ab6dd1d52a6ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2be5f7fbfeb00dc7ff8ab6dd1d52a6ef"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>isunordered</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga2be5f7fbfeb00dc7ff8ab6dd1d52a6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbb9de8f1faf8628d55b425c98467e58"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabbb9de8f1faf8628d55b425c98467e58"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>ldexp</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gabbb9de8f1faf8628d55b425c98467e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b44cf8571c500b30e16b673f584a774"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0b44cf8571c500b30e16b673f584a774"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>length</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga0b44cf8571c500b30e16b673f584a774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga301b3a1917947e04862ec1e9c4c8f6f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga301b3a1917947e04862ec1e9c4c8f6f0"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>lgamma</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga301b3a1917947e04862ec1e9c4c8f6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacd86ad12a7236f3eca9d6c8255e5295"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaacd86ad12a7236f3eca9d6c8255e5295"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>lgamma_r</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gaacd86ad12a7236f3eca9d6c8255e5295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad95cebee39c6233319ee38e4727e2324"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad95cebee39c6233319ee38e4727e2324"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>log</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gad95cebee39c6233319ee38e4727e2324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac2093b1a4d2ffb8443988507028db75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaac2093b1a4d2ffb8443988507028db75"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>log10</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gaac2093b1a4d2ffb8443988507028db75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3dfd25cd45e5d3b88cdd83c96d9ccf5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae3dfd25cd45e5d3b88cdd83c96d9ccf5"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>log1p</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gae3dfd25cd45e5d3b88cdd83c96d9ccf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e761d886c1de33d4aca5036b01d9957"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1e761d886c1de33d4aca5036b01d9957"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>log2</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga1e761d886c1de33d4aca5036b01d9957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa37982c292fe1fdccbe55713ca8b110a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa37982c292fe1fdccbe55713ca8b110a"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>logb</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gaa37982c292fe1fdccbe55713ca8b110a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27fd902a3f9dcb8b5ab1d79ba1431291"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga27fd902a3f9dcb8b5ab1d79ba1431291"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>mad</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga27fd902a3f9dcb8b5ab1d79ba1431291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b88e7ee6dd0d22107843803f1454b61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3b88e7ee6dd0d22107843803f1454b61"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>mad24</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga3b88e7ee6dd0d22107843803f1454b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5876f45a3febf148b74fba5c805a4b1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5876f45a3febf148b74fba5c805a4b1d"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>mad_hi</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga5876f45a3febf148b74fba5c805a4b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3c540f4f4cf5e7642d51123802d19a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad3c540f4f4cf5e7642d51123802d19a4"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>mad_sat</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gad3c540f4f4cf5e7642d51123802d19a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa80318003f0f8e9fe91affb70241ea57"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa80318003f0f8e9fe91affb70241ea57"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>max</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gaa80318003f0f8e9fe91affb70241ea57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f3c8368878f14266fca5f004eeec450"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8f3c8368878f14266fca5f004eeec450"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>maxmag</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga8f3c8368878f14266fca5f004eeec450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e0a147e86b4d5f19841bee01b9a206f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8e0a147e86b4d5f19841bee01b9a206f"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>min</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga8e0a147e86b4d5f19841bee01b9a206f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1860c522cbc84fe940ea5e8f3cc7d441"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1860c522cbc84fe940ea5e8f3cc7d441"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>minmag</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga1860c522cbc84fe940ea5e8f3cc7d441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64882e5eb3c210e551f5610e04b9fd72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga64882e5eb3c210e551f5610e04b9fd72"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>mix</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga64882e5eb3c210e551f5610e04b9fd72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29024a7a006aecd191c4ef7d6b6de886"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga29024a7a006aecd191c4ef7d6b6de886"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>modf</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga29024a7a006aecd191c4ef7d6b6de886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga691af6450b9528e3a60107310d64a1c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga691af6450b9528e3a60107310d64a1c4"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>mul_hi</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga691af6450b9528e3a60107310d64a1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e18d2d32bbc0fe53c4e614e31e5f206"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2e18d2d32bbc0fe53c4e614e31e5f206"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>nan</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga2e18d2d32bbc0fe53c4e614e31e5f206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e5c703fa600f80df0ad3a37d27f5db5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6e5c703fa600f80df0ad3a37d27f5db5"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>nextafter</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga6e5c703fa600f80df0ad3a37d27f5db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c0843f5a84003d686f2bbb68d460562"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8c0843f5a84003d686f2bbb68d460562"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>normalize</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga8c0843f5a84003d686f2bbb68d460562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00cb0a81a948d63602fb6e17cb97b2b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga00cb0a81a948d63602fb6e17cb97b2b9"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>pow</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga00cb0a81a948d63602fb6e17cb97b2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace4cbb1dd8680382d583dbeb9e216c30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gace4cbb1dd8680382d583dbeb9e216c30"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>pown</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gace4cbb1dd8680382d583dbeb9e216c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab67a27151c8998ec93850dd14cb63469"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab67a27151c8998ec93850dd14cb63469"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>powr</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gab67a27151c8998ec93850dd14cb63469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga699c65e69e28f487f3825693c91411f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga699c65e69e28f487f3825693c91411f8"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>radians</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga699c65e69e28f487f3825693c91411f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a5e4d726bdd159a9c9b8e83b1037462"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9a5e4d726bdd159a9c9b8e83b1037462"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>remainder</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga9a5e4d726bdd159a9c9b8e83b1037462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae59994d62671f8e526d9e9fef1722e5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae59994d62671f8e526d9e9fef1722e5f"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>remquo</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gae59994d62671f8e526d9e9fef1722e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa09b1e85edc229d63e2faf986767969f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa09b1e85edc229d63e2faf986767969f"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>rhadd</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gaa09b1e85edc229d63e2faf986767969f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10693e91ee3e67093502c3f8b97bcd42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga10693e91ee3e67093502c3f8b97bcd42"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>rint</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga10693e91ee3e67093502c3f8b97bcd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61c1bb64a0d9c902fb4bc7455ed8e20d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga61c1bb64a0d9c902fb4bc7455ed8e20d"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>rootn</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga61c1bb64a0d9c902fb4bc7455ed8e20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabf8c625b62a91195d1dd9d995911136"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaabf8c625b62a91195d1dd9d995911136"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>rotate</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gaabf8c625b62a91195d1dd9d995911136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga362dc44dbeba2a55e8cfaa9ce22a7b2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga362dc44dbeba2a55e8cfaa9ce22a7b2d"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>round</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga362dc44dbeba2a55e8cfaa9ce22a7b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9a9fd5fc1d65842ecbd1073bd7dd4be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac9a9fd5fc1d65842ecbd1073bd7dd4be"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>rsqrt</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gac9a9fd5fc1d65842ecbd1073bd7dd4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63269076b29ba9a7d79ec4debb493ea0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga63269076b29ba9a7d79ec4debb493ea0"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>select</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga63269076b29ba9a7d79ec4debb493ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga107a9ca0357e16fb1b5305cf12949956"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga107a9ca0357e16fb1b5305cf12949956"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>shuffle</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga107a9ca0357e16fb1b5305cf12949956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f947d81838d203416332d2f13f23951"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2f947d81838d203416332d2f13f23951"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>shuffle2</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga2f947d81838d203416332d2f13f23951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12054c58ba435f1274ddc9dcb408514d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga12054c58ba435f1274ddc9dcb408514d"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>sign</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga12054c58ba435f1274ddc9dcb408514d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d8d764689475fb1ab7aad635e92d4ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7d8d764689475fb1ab7aad635e92d4ca"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>signbit</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga7d8d764689475fb1ab7aad635e92d4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab79725de000beceaf5aeb333e2b6d86e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab79725de000beceaf5aeb333e2b6d86e"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>sin</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gab79725de000beceaf5aeb333e2b6d86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2afa90bd2e89b6c62cb0467acf21fc51"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2afa90bd2e89b6c62cb0467acf21fc51"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>sincos</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga2afa90bd2e89b6c62cb0467acf21fc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c1eaf2fa5dce715178e2b087576416e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6c1eaf2fa5dce715178e2b087576416e"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>sinh</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga6c1eaf2fa5dce715178e2b087576416e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb169da7928024e9db1c544d5588c955"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadb169da7928024e9db1c544d5588c955"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>sinpi</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gadb169da7928024e9db1c544d5588c955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45c95b85a48d1e035b705aa509b28f46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga45c95b85a48d1e035b705aa509b28f46"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>smoothstep</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga45c95b85a48d1e035b705aa509b28f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34ceecba612bbcb250370476c3cb0851"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga34ceecba612bbcb250370476c3cb0851"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>sqrt</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga34ceecba612bbcb250370476c3cb0851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20b773bb26958df8b34ed1c97cb9e85f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga20b773bb26958df8b34ed1c97cb9e85f"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>step</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga20b773bb26958df8b34ed1c97cb9e85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fec13624b3940706e50d69d0f6474f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4fec13624b3940706e50d69d0f6474f9"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>sub_sat</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga4fec13624b3940706e50d69d0f6474f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab349303eea9719e14fafedbd03cf3ab0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab349303eea9719e14fafedbd03cf3ab0"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>tan</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gab349303eea9719e14fafedbd03cf3ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f665550e4f8c5fb3f92d260b339d75e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1f665550e4f8c5fb3f92d260b339d75e"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>tanh</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga1f665550e4f8c5fb3f92d260b339d75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f4f76d0a92fd099d2ae7b06a93f16b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3f4f76d0a92fd099d2ae7b06a93f16b2"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>tanpi</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga3f4f76d0a92fd099d2ae7b06a93f16b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e8c8fb63573071caa609ff17a738355"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4e8c8fb63573071caa609ff17a738355"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>tgamma</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga4e8c8fb63573071caa609ff17a738355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3a5e3a0d159e751d9447ea1907bda56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac3a5e3a0d159e751d9447ea1907bda56"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>trunc</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:gac3a5e3a0d159e751d9447ea1907bda56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga143be8b1061466ed13c1a7942f5031e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga143be8b1061466ed13c1a7942f5031e2"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>upsample</b> (const Arg0 &amp;arg0,...const ArgN &amp;argN)</td></tr>
<tr class="separator:ga143be8b1061466ed13c1a7942f5031e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03af37d33d70d57749d6e0454caa8cf9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga03af37d33d70d57749d6e0454caa8cf9"></a>
expression&#160;</td><td class="memItemRight" valign="bottom"><b>abs</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:ga03af37d33d70d57749d6e0454caa8cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309be2ac9197a3a1f16c3f58da32e4a5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a309be2ac9197a3a1f16c3f58da32e4a5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a309be2ac9197a3a1f16c3f58da32e4a5"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a309be2ac9197a3a1f16c3f58da32e4a5">operator&lt;&lt;</a> (std::ostream &amp;os, const symbolic&lt; T &gt; &amp;sym)</td></tr>
<tr class="memdesc:a309be2ac9197a3a1f16c3f58da32e4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends name of the symbolic variable to output stream. <br /></td></tr>
<tr class="separator:a309be2ac9197a3a1f16c3f58da32e4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6532fb0bd5162d419fba16f8d6995509"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6532fb0bd5162d419fba16f8d6995509"></a>
template&lt;class RDC , typename T , size_t NDIM, size_t NR&gt; </td></tr>
<tr class="memitem:a6532fb0bd5162d419fba16f8d6995509"><td class="memTemplItemLeft" align="right" valign="top">reduced_vector_view&lt; const <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &amp;, NDIM, NR, RDC &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a6532fb0bd5162d419fba16f8d6995509">reduce</a> (const multi_array&lt; T, NDIM &gt; &amp;m, const std::array&lt; size_t, NR &gt; &amp;reduce_dims)</td></tr>
<tr class="memdesc:a6532fb0bd5162d419fba16f8d6995509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce vex::multi_array along the specified dimensions. <br /></td></tr>
<tr class="separator:a6532fb0bd5162d419fba16f8d6995509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6810d221bd432fec4db9b83d7176ddb8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6810d221bd432fec4db9b83d7176ddb8"></a>
template&lt;class RDC , typename T , size_t NDIM&gt; </td></tr>
<tr class="memitem:a6810d221bd432fec4db9b83d7176ddb8"><td class="memTemplItemLeft" align="right" valign="top">reduced_vector_view&lt; const <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &amp;, NDIM, 1, RDC &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a6810d221bd432fec4db9b83d7176ddb8">reduce</a> (const multi_array&lt; T, NDIM &gt; &amp;m, size_t reduce_dim)</td></tr>
<tr class="memdesc:a6810d221bd432fec4db9b83d7176ddb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce vex::multi_array along the specified dimension. <br /></td></tr>
<tr class="separator:a6810d221bd432fec4db9b83d7176ddb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa68b032f0d66695e3b3b6c5375e8cf6"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaa68b032f0d66695e3b3b6c5375e8cf6"></a>
template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:aaa68b032f0d66695e3b3b6c5375e8cf6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#aaa68b032f0d66695e3b3b6c5375e8cf6">copy</a> (const <a class="el" href="classvex_1_1multivector.html">multivector</a>&lt; T, N &gt; &amp;mv, std::vector&lt; T &gt; &amp;hv)</td></tr>
<tr class="memdesc:aaa68b032f0d66695e3b3b6c5375e8cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy multivector to host vector. <br /></td></tr>
<tr class="separator:aaa68b032f0d66695e3b3b6c5375e8cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11afb8e8e5387abf04e3b7f815111e0e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a11afb8e8e5387abf04e3b7f815111e0e"></a>
template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:a11afb8e8e5387abf04e3b7f815111e0e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a11afb8e8e5387abf04e3b7f815111e0e">copy</a> (const std::vector&lt; T &gt; &amp;hv, <a class="el" href="classvex_1_1multivector.html">multivector</a>&lt; T, N &gt; &amp;mv)</td></tr>
<tr class="memdesc:a11afb8e8e5387abf04e3b7f815111e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy host vector to multivector. <br /></td></tr>
<tr class="separator:a11afb8e8e5387abf04e3b7f815111e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8aaad637ee6e4c8527222b58ddd1089"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab8aaad637ee6e4c8527222b58ddd1089"></a>
template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:ab8aaad637ee6e4c8527222b58ddd1089"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ab8aaad637ee6e4c8527222b58ddd1089">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classvex_1_1multivector.html">vex::multivector</a>&lt; T, N &gt; &amp;t)</td></tr>
<tr class="memdesc:ab8aaad637ee6e4c8527222b58ddd1089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Download and print the vector elements. <br /></td></tr>
<tr class="separator:ab8aaad637ee6e4c8527222b58ddd1089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ed95396644bcef1aff9a0cac89e69a"><td class="memTemplParams" colspan="2">template&lt;class... Expr&gt; </td></tr>
<tr class="memitem:ab7ed95396644bcef1aff9a0cac89e69a"><td class="memTemplItemLeft" align="right" valign="top">expression_tuple&lt; std::tuple&lt; const Expr &amp;...&gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ab7ed95396644bcef1aff9a0cac89e69a">tie</a> (const Expr &amp;...expr)</td></tr>
<tr class="memdesc:ab7ed95396644bcef1aff9a0cac89e69a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ties several vector expressions into writeable tuple.  <a href="#ab7ed95396644bcef1aff9a0cac89e69a">More...</a><br /></td></tr>
<tr class="separator:ab7ed95396644bcef1aff9a0cac89e69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2218b98674ff19fb08a82842a0a5646"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa2218b98674ff19fb08a82842a0a5646"></a>
template&lt;typename IKeys , typename OKeys , typename V , class Comp , class Oper &gt; </td></tr>
<tr class="memitem:aa2218b98674ff19fb08a82842a0a5646"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#aa2218b98674ff19fb08a82842a0a5646">reduce_by_key</a> (IKeys &amp;&amp;ikeys, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; V &gt; const &amp;ivals, OKeys &amp;&amp;okeys, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; V &gt; &amp;ovals, Comp comp, Oper oper)</td></tr>
<tr class="memdesc:aa2218b98674ff19fb08a82842a0a5646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce by key algorithm. <br /></td></tr>
<tr class="separator:aa2218b98674ff19fb08a82842a0a5646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae253d3b2dd8a5fd26a14dec81d8a51c2"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae253d3b2dd8a5fd26a14dec81d8a51c2"></a>
template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:ae253d3b2dd8a5fd26a14dec81d8a51c2"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ae253d3b2dd8a5fd26a14dec81d8a51c2">reduce_by_key</a> (<a class="el" href="classvex_1_1vector.html">vector</a>&lt; K &gt; const &amp;ikeys, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; V &gt; const &amp;ivals, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; K &gt; &amp;okeys, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; V &gt; &amp;ovals)</td></tr>
<tr class="memdesc:ae253d3b2dd8a5fd26a14dec81d8a51c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce by key algorithm. <br /></td></tr>
<tr class="separator:ae253d3b2dd8a5fd26a14dec81d8a51c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a84e6989c6710c5a9fcc621b85cf00"><td class="memTemplParams" colspan="2">template&lt;typename T , class R &gt; </td></tr>
<tr class="memitem:a30a84e6989c6710c5a9fcc621b85cf00"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classvex_1_1Reductor.html">vex::Reductor</a>&lt; T, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a30a84e6989c6710c5a9fcc621b85cf00">get_reductor</a> (const std::vector&lt; <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &gt; &amp;queue)</td></tr>
<tr class="memdesc:a30a84e6989c6710c5a9fcc621b85cf00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of vex::Reductor&lt;T,R&gt;  <a href="#a30a84e6989c6710c5a9fcc621b85cf00">More...</a><br /></td></tr>
<tr class="separator:a30a84e6989c6710c5a9fcc621b85cf00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc18f46eb80f11430bd7d1fd224e4df"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8fc18f46eb80f11430bd7d1fd224e4df"></a>
template&lt;typename T , class Oper &gt; </td></tr>
<tr class="memitem:a8fc18f46eb80f11430bd7d1fd224e4df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a8fc18f46eb80f11430bd7d1fd224e4df">inclusive_scan</a> (<a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; const &amp;input, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &amp;output, T init, Oper oper)</td></tr>
<tr class="memdesc:a8fc18f46eb80f11430bd7d1fd224e4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inclusive scan. <br /></td></tr>
<tr class="separator:a8fc18f46eb80f11430bd7d1fd224e4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536ee0effdd0c81b2252ddf7bf0cb3a9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a536ee0effdd0c81b2252ddf7bf0cb3a9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a536ee0effdd0c81b2252ddf7bf0cb3a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a536ee0effdd0c81b2252ddf7bf0cb3a9">inclusive_scan</a> (<a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; const &amp;input, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &amp;output, T init=T())</td></tr>
<tr class="memdesc:a536ee0effdd0c81b2252ddf7bf0cb3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inclusive scan. <br /></td></tr>
<tr class="separator:a536ee0effdd0c81b2252ddf7bf0cb3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d36c4ddd6b769349ebb2c11badf2199"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4d36c4ddd6b769349ebb2c11badf2199"></a>
template&lt;typename T , class Oper &gt; </td></tr>
<tr class="memitem:a4d36c4ddd6b769349ebb2c11badf2199"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a4d36c4ddd6b769349ebb2c11badf2199">exclusive_scan</a> (<a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; const &amp;input, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &amp;output, T init, Oper oper)</td></tr>
<tr class="memdesc:a4d36c4ddd6b769349ebb2c11badf2199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exclusive scan. <br /></td></tr>
<tr class="separator:a4d36c4ddd6b769349ebb2c11badf2199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523b47ce4da35257c05e7d509e69db2d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a523b47ce4da35257c05e7d509e69db2d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a523b47ce4da35257c05e7d509e69db2d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a523b47ce4da35257c05e7d509e69db2d">exclusive_scan</a> (<a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; const &amp;input, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &amp;output, T init=T())</td></tr>
<tr class="memdesc:a523b47ce4da35257c05e7d509e69db2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exclusive scan. <br /></td></tr>
<tr class="separator:a523b47ce4da35257c05e7d509e69db2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a23ba1e0747ab6c66bdf325db90b7d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a47a23ba1e0747ab6c66bdf325db90b7d"></a>
template&lt;class KTuple , typename V , class Comp , class Oper &gt; </td></tr>
<tr class="memitem:a47a23ba1e0747ab6c66bdf325db90b7d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a47a23ba1e0747ab6c66bdf325db90b7d">exclusive_scan_by_key</a> (KTuple &amp;&amp;keys, const <a class="el" href="classvex_1_1vector.html">vector</a>&lt; V &gt; &amp;ivals, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; V &gt; &amp;ovals, Comp comp, Oper oper, V init=V())</td></tr>
<tr class="memdesc:a47a23ba1e0747ab6c66bdf325db90b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exclusive scan by key algorithm. <br /></td></tr>
<tr class="separator:a47a23ba1e0747ab6c66bdf325db90b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b721170cd9f8e4a55baa5c327338c0b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5b721170cd9f8e4a55baa5c327338c0b"></a>
template&lt;class KTuple , typename V , class Comp , class Oper &gt; </td></tr>
<tr class="memitem:a5b721170cd9f8e4a55baa5c327338c0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a5b721170cd9f8e4a55baa5c327338c0b">inclusive_scan_by_key</a> (KTuple &amp;&amp;keys, const <a class="el" href="classvex_1_1vector.html">vector</a>&lt; V &gt; &amp;ivals, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; V &gt; &amp;ovals, Comp comp, Oper oper, V init=V())</td></tr>
<tr class="memdesc:a5b721170cd9f8e4a55baa5c327338c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inclusive scan by key algorithm. <br /></td></tr>
<tr class="separator:a5b721170cd9f8e4a55baa5c327338c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3f1ecd1b247476739fc9174c7a9a2e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2c3f1ecd1b247476739fc9174c7a9a2e"></a>
template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a2c3f1ecd1b247476739fc9174c7a9a2e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a2c3f1ecd1b247476739fc9174c7a9a2e">exclusive_scan_by_key</a> (const <a class="el" href="classvex_1_1vector.html">vector</a>&lt; K &gt; &amp;keys, const <a class="el" href="classvex_1_1vector.html">vector</a>&lt; V &gt; &amp;ivals, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; V &gt; &amp;ovals, V init=V())</td></tr>
<tr class="memdesc:a2c3f1ecd1b247476739fc9174c7a9a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exclusive scan by key algorithm. <br /></td></tr>
<tr class="separator:a2c3f1ecd1b247476739fc9174c7a9a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc94f17411f95d6f41caeb3589dde91"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1cc94f17411f95d6f41caeb3589dde91"></a>
template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a1cc94f17411f95d6f41caeb3589dde91"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a1cc94f17411f95d6f41caeb3589dde91">inclusive_scan_by_key</a> (const <a class="el" href="classvex_1_1vector.html">vector</a>&lt; K &gt; &amp;keys, const <a class="el" href="classvex_1_1vector.html">vector</a>&lt; V &gt; &amp;ivals, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; V &gt; &amp;ovals, V init=V())</td></tr>
<tr class="memdesc:a1cc94f17411f95d6f41caeb3589dde91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inclusive scan by key algorithm. <br /></td></tr>
<tr class="separator:a1cc94f17411f95d6f41caeb3589dde91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b2ded8868f71bc74e4e270d2a8dae9"><td class="memTemplParams" colspan="2">template&lt;class K , class Comp &gt; </td></tr>
<tr class="memitem:a84b2ded8868f71bc74e4e270d2a8dae9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a84b2ded8868f71bc74e4e270d2a8dae9">sort</a> (K &amp;&amp;keys, Comp comp)</td></tr>
<tr class="memdesc:a84b2ded8868f71bc74e4e270d2a8dae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the vector into ascending order.  <a href="#a84b2ded8868f71bc74e4e270d2a8dae9">More...</a><br /></td></tr>
<tr class="separator:a84b2ded8868f71bc74e4e270d2a8dae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bc72755a950140b17b769133e9147a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a60bc72755a950140b17b769133e9147a"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:a60bc72755a950140b17b769133e9147a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a60bc72755a950140b17b769133e9147a">sort</a> (<a class="el" href="classvex_1_1vector.html">vector</a>&lt; K &gt; &amp;keys)</td></tr>
<tr class="memdesc:a60bc72755a950140b17b769133e9147a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in keys and values into ascending key order. <br /></td></tr>
<tr class="separator:a60bc72755a950140b17b769133e9147a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0d7aa078f1ae079e3a06708d9b84b6"><td class="memTemplParams" colspan="2">template&lt;class K , class V , class Comp &gt; </td></tr>
<tr class="memitem:a6c0d7aa078f1ae079e3a06708d9b84b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a6c0d7aa078f1ae079e3a06708d9b84b6">sort_by_key</a> (K &amp;&amp;keys, V &amp;&amp;vals, Comp comp)</td></tr>
<tr class="memdesc:a6c0d7aa078f1ae079e3a06708d9b84b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in keys and values into ascending key order.  <a href="#a6c0d7aa078f1ae079e3a06708d9b84b6">More...</a><br /></td></tr>
<tr class="separator:a6c0d7aa078f1ae079e3a06708d9b84b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b043fcc5a4892ef36b5b6b8a218f38"><td class="memTemplParams" colspan="2"><a class="anchor" id="a29b043fcc5a4892ef36b5b6b8a218f38"></a>
template&lt;class K , class V &gt; </td></tr>
<tr class="memitem:a29b043fcc5a4892ef36b5b6b8a218f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a29b043fcc5a4892ef36b5b6b8a218f38">sort_by_key</a> (<a class="el" href="classvex_1_1vector.html">vector</a>&lt; K &gt; &amp;keys, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; V &gt; &amp;vals)</td></tr>
<tr class="memdesc:a29b043fcc5a4892ef36b5b6b8a218f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in keys and values into ascending key order. <br /></td></tr>
<tr class="separator:a29b043fcc5a4892ef36b5b6b8a218f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04547c51b46e0005b37ad00493f7354"><td class="memTemplParams" colspan="2">template&lt;typename val_t , typename col_t , typename idx_t &gt; </td></tr>
<tr class="memitem:aa04547c51b46e0005b37ad00493f7354"><td class="memTemplItemLeft" align="right" valign="top">inline_spmv&lt; <a class="el" href="classvex_1_1SpMat.html">SpMat</a>&lt; val_t, col_t, idx_t &gt;, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; val_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#aa04547c51b46e0005b37ad00493f7354">make_inline</a> (const additive_operator&lt;<a class="el" href="classvex_1_1SpMat.html">SpMat</a>&lt; val_t, col_t, idx_t &gt;, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; val_t &gt; &gt; &amp;base)</td></tr>
<tr class="memdesc:aa04547c51b46e0005b37ad00493f7354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlines a sparse matrix - vector product.  <a href="#aa04547c51b46e0005b37ad00493f7354">More...</a><br /></td></tr>
<tr class="separator:aa04547c51b46e0005b37ad00493f7354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74a209f956b87b8dc289aad5498a25c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#ac74a209f956b87b8dc289aad5498a25c">device_spmv_perf</a> (const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;q)</td></tr>
<tr class="memdesc:ac74a209f956b87b8dc289aad5498a25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weights device wrt to additive_operator performance.  <a href="#ac74a209f956b87b8dc289aad5498a25c">More...</a><br /></td></tr>
<tr class="separator:ac74a209f956b87b8dc289aad5498a25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6771b696fd85328302dfc97cfcdb2a"><td class="memTemplParams" colspan="2"><a class="anchor" id="aab6771b696fd85328302dfc97cfcdb2a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aab6771b696fd85328302dfc97cfcdb2a"><td class="memTemplItemLeft" align="right" valign="top">additive_operator&lt;<a class="el" href="classvex_1_1stencil.html">stencil</a>&lt; T &gt;, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#aab6771b696fd85328302dfc97cfcdb2a">operator*</a> (const <a class="el" href="classvex_1_1stencil.html">stencil</a>&lt; T &gt; &amp;s, const <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:aab6771b696fd85328302dfc97cfcdb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve the stencil with the vector. <br /></td></tr>
<tr class="separator:aab6771b696fd85328302dfc97cfcdb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e2970a3749f0158f51a485907a6576"><td class="memTemplParams" colspan="2"><a class="anchor" id="a43e2970a3749f0158f51a485907a6576"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a43e2970a3749f0158f51a485907a6576"><td class="memTemplItemLeft" align="right" valign="top">additive_operator&lt;<a class="el" href="classvex_1_1stencil.html">stencil</a>&lt; T &gt;, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a43e2970a3749f0158f51a485907a6576">operator*</a> (const <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &amp;x, const <a class="el" href="classvex_1_1stencil.html">stencil</a>&lt; T &gt; &amp;s)</td></tr>
<tr class="memdesc:a43e2970a3749f0158f51a485907a6576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve the stencil with the vector. <br /></td></tr>
<tr class="separator:a43e2970a3749f0158f51a485907a6576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46ae67da517dca8015475e021e7ab27"><td class="memTemplParams" colspan="2">template&lt;size_t Tag, class Expr &gt; </td></tr>
<tr class="memitem:ab46ae67da517dca8015475e021e7ab27"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ab46ae67da517dca8015475e021e7ab27">tag</a> (const Expr &amp;expr) -&gt; const tagged_terminal&lt; Tag, decltype(boost::proto::as_child&lt; vector_domain &gt;(expr)) &gt;</td></tr>
<tr class="memdesc:ab46ae67da517dca8015475e021e7ab27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tags terminal with a unique (in a single expression) tag.  <a href="#ab46ae67da517dca8015475e021e7ab27">More...</a><br /></td></tr>
<tr class="separator:ab46ae67da517dca8015475e021e7ab27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e84dcac8995e5fbfb0cc2848d94297"><td class="memTemplParams" colspan="2">template&lt;size_t Tag, typename T , class Expr &gt; </td></tr>
<tr class="memitem:ae1e84dcac8995e5fbfb0cc2848d94297"><td class="memTemplItemLeft" align="right" valign="top">temporary&lt; T, Tag, Expr &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ae1e84dcac8995e5fbfb0cc2848d94297">make_temp</a> (const Expr &amp;expr)</td></tr>
<tr class="memdesc:ae1e84dcac8995e5fbfb0cc2848d94297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create temporary to be reused in a vector expression.  <a href="#ae1e84dcac8995e5fbfb0cc2848d94297">More...</a><br /></td></tr>
<tr class="separator:ae1e84dcac8995e5fbfb0cc2848d94297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad59a3b060765aaee879da333ac3a812"><td class="memTemplParams" colspan="2">template&lt;size_t Tag, class Expr &gt; </td></tr>
<tr class="memitem:aad59a3b060765aaee879da333ac3a812"><td class="memTemplItemLeft" align="right" valign="top">temporary&lt; typename detail::return_type&lt; Expr &gt;::type, Tag, Expr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#aad59a3b060765aaee879da333ac3a812">make_temp</a> (const Expr &amp;expr)</td></tr>
<tr class="memdesc:aad59a3b060765aaee879da333ac3a812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create temporary to be reused in a vector expression.  <a href="#aad59a3b060765aaee879da333ac3a812">More...</a><br /></td></tr>
<tr class="separator:aad59a3b060765aaee879da333ac3a812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb82a55e98b3fb4747a1419c5517e951"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:acb82a55e98b3fb4747a1419c5517e951"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; size_t, 2 &gt;, sizeof...(Args)/2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#acb82a55e98b3fb4747a1419c5517e951">axes_pairs</a> (Args...args)</td></tr>
<tr class="memdesc:acb82a55e98b3fb4747a1419c5517e951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for creating axes pairs.  <a href="#acb82a55e98b3fb4747a1419c5517e951">More...</a><br /></td></tr>
<tr class="separator:acb82a55e98b3fb4747a1419c5517e951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bba54b573a11a64010edb37f03b98d2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5bba54b573a11a64010edb37f03b98d2"></a>
template&lt;class LHS , size_t LDIM, class RHS , size_t RDIM, size_t CDIM&gt; </td></tr>
<tr class="memitem:a5bba54b573a11a64010edb37f03b98d2"><td class="memTemplItemLeft" align="right" valign="top">tensordot_expr&lt; LHS, LDIM, RHS, RDIM, CDIM &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a5bba54b573a11a64010edb37f03b98d2">tensordot</a> (const vector_view&lt; LHS, <a class="el" href="structvex_1_1gslice.html">gslice</a>&lt; LDIM &gt;&gt; &amp;lhs, const vector_view&lt; RHS, <a class="el" href="structvex_1_1gslice.html">gslice</a>&lt; RDIM &gt;&gt; &amp;rhs, const std::array&lt; std::array&lt; size_t, 2 &gt;, CDIM &gt; &amp;common_axes)</td></tr>
<tr class="memdesc:a5bba54b573a11a64010edb37f03b98d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor dot product along specified axes for multidimensional arrays. <br /></td></tr>
<tr class="separator:a5bba54b573a11a64010edb37f03b98d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c7748602834bd3b8b86762a0970a94"><td class="memTemplParams" colspan="2">template&lt;class Condition , class Message &gt; </td></tr>
<tr class="memitem:a94c7748602834bd3b8b86762a0970a94"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a94c7748602834bd3b8b86762a0970a94">precondition</a> (const Condition &amp;condition, const Message &amp;fail_message)</td></tr>
<tr class="memdesc:a94c7748602834bd3b8b86762a0970a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check run-time condition.  <a href="#a94c7748602834bd3b8b86762a0970a94">More...</a><br /></td></tr>
<tr class="separator:a94c7748602834bd3b8b86762a0970a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08607ab86b8756c1bd30c651c6a7ab3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08607ab86b8756c1bd30c651c6a7ab3b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a08607ab86b8756c1bd30c651c6a7ab3b">nextpow2</a> (size_t x)</td></tr>
<tr class="memdesc:a08607ab86b8756c1bd30c651c6a7ab3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return next power of 2. <br /></td></tr>
<tr class="separator:a08607ab86b8756c1bd30c651c6a7ab3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde6e399118c4e9c8fdb111d23d65698"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adde6e399118c4e9c8fdb111d23d65698"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#adde6e399118c4e9c8fdb111d23d65698">alignup</a> (size_t n, size_t m=16U)</td></tr>
<tr class="memdesc:adde6e399118c4e9c8fdb111d23d65698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Align n to the next multiple of m. <br /></td></tr>
<tr class="separator:adde6e399118c4e9c8fdb111d23d65698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec621a57aaa5e1e17619376714b34c6"><td class="memTemplParams" colspan="2"><a class="anchor" id="acec621a57aaa5e1e17619376714b34c6"></a>
template&lt;class T , class... Tail&gt; </td></tr>
<tr class="memitem:acec621a57aaa5e1e17619376714b34c6"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, 1+sizeof...(Tail)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#acec621a57aaa5e1e17619376714b34c6">make_array</a> (T t, Tail...tail)</td></tr>
<tr class="memdesc:acec621a57aaa5e1e17619376714b34c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create std::array from arguments. <br /></td></tr>
<tr class="separator:acec621a57aaa5e1e17619376714b34c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3688791c9b5aa7a26c7a63d9684b481c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a3688791c9b5aa7a26c7a63d9684b481c">device_vector_perf</a> (const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;)</td></tr>
<tr class="memdesc:a3688791c9b5aa7a26c7a63d9684b481c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weights device wrt to vector performance.  <a href="#a3688791c9b5aa7a26c7a63d9684b481c">More...</a><br /></td></tr>
<tr class="separator:a3688791c9b5aa7a26c7a63d9684b481c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629ee8dc1d5241fcfbc0289fbb8e7b0e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a629ee8dc1d5241fcfbc0289fbb8e7b0e">equal_weights</a> (const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;)</td></tr>
<tr class="memdesc:a629ee8dc1d5241fcfbc0289fbb8e7b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns equal weight to each device.  <a href="#a629ee8dc1d5241fcfbc0289fbb8e7b0e">More...</a><br /></td></tr>
<tr class="separator:a629ee8dc1d5241fcfbc0289fbb8e7b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7740d79c763aba34de005e957fb27db5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a7740d79c763aba34de005e957fb27db5">set_partitioning</a> (std::function&lt; double(const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;) &gt; f)</td></tr>
<tr class="memdesc:a7740d79c763aba34de005e957fb27db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitioning scheme for vectors and matrices.  <a href="#a7740d79c763aba34de005e957fb27db5">More...</a><br /></td></tr>
<tr class="separator:a7740d79c763aba34de005e957fb27db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08b03eaab6548720caf55e47f5cfc91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae08b03eaab6548720caf55e47f5cfc91"></a>
std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#ae08b03eaab6548720caf55e47f5cfc91">partition</a> (size_t n, const std::vector&lt; <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &gt; &amp;queue)</td></tr>
<tr class="memdesc:ae08b03eaab6548720caf55e47f5cfc91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns partitioning for the specified vector size on a given set of queues. <br /></td></tr>
<tr class="separator:ae08b03eaab6548720caf55e47f5cfc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135f84b29097383ebaeafc866785fdd9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a135f84b29097383ebaeafc866785fdd9"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a135f84b29097383ebaeafc866785fdd9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a135f84b29097383ebaeafc866785fdd9">copy</a> (const <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt; &amp;dv, std::vector&lt; T &gt; &amp;hv, bool blocking=true)</td></tr>
<tr class="memdesc:a135f84b29097383ebaeafc866785fdd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy device vector to host vector. <br /></td></tr>
<tr class="separator:a135f84b29097383ebaeafc866785fdd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38ed8c7913492957642ba36137e3dad"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad38ed8c7913492957642ba36137e3dad"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad38ed8c7913492957642ba36137e3dad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ad38ed8c7913492957642ba36137e3dad">copy</a> (const <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt; &amp;dv, T *hv, bool blocking=true)</td></tr>
<tr class="memdesc:ad38ed8c7913492957642ba36137e3dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy device vector to host pointer. <br /></td></tr>
<tr class="separator:ad38ed8c7913492957642ba36137e3dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2cb4d14c4be271957e991da2dc475c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4c2cb4d14c4be271957e991da2dc475c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4c2cb4d14c4be271957e991da2dc475c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a4c2cb4d14c4be271957e991da2dc475c">copy</a> (const std::vector&lt; T &gt; &amp;hv, <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt; &amp;dv, bool blocking=true)</td></tr>
<tr class="memdesc:a4c2cb4d14c4be271957e991da2dc475c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy host vector to device vector. <br /></td></tr>
<tr class="separator:a4c2cb4d14c4be271957e991da2dc475c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac276f100e959f4afed345409ee2bc50d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac276f100e959f4afed345409ee2bc50d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac276f100e959f4afed345409ee2bc50d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ac276f100e959f4afed345409ee2bc50d">copy</a> (const T *hv, <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt; &amp;dv, bool blocking=true)</td></tr>
<tr class="memdesc:ac276f100e959f4afed345409ee2bc50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy host pointer to device vector. <br /></td></tr>
<tr class="separator:ac276f100e959f4afed345409ee2bc50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae178cb03057d2aed93ab059c78631e8b"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:ae178cb03057d2aed93ab059c78631e8b"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ae178cb03057d2aed93ab059c78631e8b">copy</a> (InputIterator first, InputIterator last, OutputIterator result, bool blocking=true)</td></tr>
<tr class="memdesc:ae178cb03057d2aed93ab059c78631e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy range from device vector to host vector.  <a href="#ae178cb03057d2aed93ab059c78631e8b">More...</a><br /></td></tr>
<tr class="separator:ae178cb03057d2aed93ab059c78631e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c514253c0f09c5a18dac3e687553465"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6c514253c0f09c5a18dac3e687553465"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6c514253c0f09c5a18dac3e687553465"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a6c514253c0f09c5a18dac3e687553465">swap</a> (<a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &amp;x, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a6c514253c0f09c5a18dac3e687553465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two vectors. <br /></td></tr>
<tr class="separator:a6c514253c0f09c5a18dac3e687553465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7718ddf9ae8ee16668a07d874f1e4d82"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7718ddf9ae8ee16668a07d874f1e4d82"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7718ddf9ae8ee16668a07d874f1e4d82"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a7718ddf9ae8ee16668a07d874f1e4d82">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:a7718ddf9ae8ee16668a07d874f1e4d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Download and print the vector elements. <br /></td></tr>
<tr class="separator:a7718ddf9ae8ee16668a07d874f1e4d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca1d21b77d4ea7494aa032c9bb81db8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afca1d21b77d4ea7494aa032c9bb81db8"><td class="memTemplItemLeft" align="right" valign="top">vector_pointer&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#afca1d21b77d4ea7494aa032c9bb81db8">raw_pointer</a> (const <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:afca1d21b77d4ea7494aa032c9bb81db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <a class="el" href="classvex_1_1vector.html" title="Device vector. ">vex::vector</a> to a raw pointer.  <a href="#afca1d21b77d4ea7494aa032c9bb81db8">More...</a><br /></td></tr>
<tr class="separator:afca1d21b77d4ea7494aa032c9bb81db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8048e3bb5185ab018e9d0a0649ef0b"><td class="memTemplParams" colspan="2">template&lt;class Expr &gt; </td></tr>
<tr class="memitem:a1d8048e3bb5185ab018e9d0a0649ef0b"><td class="memTemplItemLeft" align="right" valign="top">expr_permutation&lt; Expr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a1d8048e3bb5185ab018e9d0a0649ef0b">permutation</a> (const Expr &amp;expr)</td></tr>
<tr class="memdesc:a1d8048e3bb5185ab018e9d0a0649ef0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns permutation functor which is based on an integral expression.  <a href="#a1d8048e3bb5185ab018e9d0a0649ef0b">More...</a><br /></td></tr>
<tr class="separator:a1d8048e3bb5185ab018e9d0a0649ef0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fee73e544429d5e986f932a26cb4408"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1fee73e544429d5e986f932a26cb4408"></a>
template&lt;class RDC , typename Expr , size_t NDIM, size_t NR&gt; </td></tr>
<tr class="memitem:a1fee73e544429d5e986f932a26cb4408"><td class="memTemplItemLeft" align="right" valign="top">reduced_vector_view&lt; Expr, NDIM, NR, RDC &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a1fee73e544429d5e986f932a26cb4408">reduce</a> (const vector_view&lt; Expr, <a class="el" href="structvex_1_1gslice.html">gslice</a>&lt; NDIM &gt; &gt; &amp;view, const std::array&lt; size_t, NR &gt; &amp;reduce_dims)</td></tr>
<tr class="memdesc:a1fee73e544429d5e986f932a26cb4408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce vector_view along specified dimensions. <br /></td></tr>
<tr class="separator:a1fee73e544429d5e986f932a26cb4408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed38cdf2814b4c0a339c59868a52ec4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8ed38cdf2814b4c0a339c59868a52ec4"></a>
template&lt;class RDC , typename Expr , size_t NDIM&gt; </td></tr>
<tr class="memitem:a8ed38cdf2814b4c0a339c59868a52ec4"><td class="memTemplItemLeft" align="right" valign="top">reduced_vector_view&lt; Expr, NDIM, 1, RDC &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a8ed38cdf2814b4c0a339c59868a52ec4">reduce</a> (const vector_view&lt; Expr, <a class="el" href="structvex_1_1gslice.html">gslice</a>&lt; NDIM &gt; &gt; &amp;view, size_t reduce_dim)</td></tr>
<tr class="memdesc:a8ed38cdf2814b4c0a339c59868a52ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce vector_view along specified dimension. <br /></td></tr>
<tr class="separator:a8ed38cdf2814b4c0a339c59868a52ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14a59d7fe62f48a61cadd5098f82f80"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab14a59d7fe62f48a61cadd5098f82f80"></a>
template&lt;class RDC , typename Expr , size_t NDIM, size_t NR&gt; </td></tr>
<tr class="memitem:ab14a59d7fe62f48a61cadd5098f82f80"><td class="memTemplItemLeft" align="right" valign="top">reduced_vector_view&lt; typename boost::proto::result_of::as_child&lt; const Expr, vector_domain &gt;::type, NDIM, NR, RDC &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ab14a59d7fe62f48a61cadd5098f82f80">reduce</a> (const <a class="el" href="structvex_1_1gslice.html">gslice</a>&lt; NDIM &gt; &amp;slice, const Expr &amp;expr, const std::array&lt; size_t, NR &gt; &amp;reduce_dims)</td></tr>
<tr class="memdesc:ab14a59d7fe62f48a61cadd5098f82f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce sliced expression along specified dimensions. <br /></td></tr>
<tr class="separator:ab14a59d7fe62f48a61cadd5098f82f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77b2a657d4d26f3b8348c9ac1be02f4"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac77b2a657d4d26f3b8348c9ac1be02f4"></a>
template&lt;class RDC , typename Expr , size_t NDIM&gt; </td></tr>
<tr class="memitem:ac77b2a657d4d26f3b8348c9ac1be02f4"><td class="memTemplItemLeft" align="right" valign="top">reduced_vector_view&lt; typename boost::proto::result_of::as_child&lt; const Expr, vector_domain &gt;::type, NDIM, 1, RDC &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ac77b2a657d4d26f3b8348c9ac1be02f4">reduce</a> (const <a class="el" href="structvex_1_1gslice.html">gslice</a>&lt; NDIM &gt; &amp;slice, const Expr &amp;expr, size_t reduce_dim)</td></tr>
<tr class="memdesc:ac77b2a657d4d26f3b8348c9ac1be02f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce sliced expression along specified dimension. <br /></td></tr>
<tr class="separator:ac77b2a657d4d26f3b8348c9ac1be02f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00792964db2b9c9b2bd784383cd46037"><td class="memTemplParams" colspan="2"><a class="anchor" id="a00792964db2b9c9b2bd784383cd46037"></a>
template&lt;class RDC , typename Expr , size_t NDIM, size_t NR&gt; </td></tr>
<tr class="memitem:a00792964db2b9c9b2bd784383cd46037"><td class="memTemplItemLeft" align="right" valign="top">reduced_vector_view&lt; typename boost::proto::result_of::as_child&lt; const Expr, vector_domain &gt;::type, NDIM, NR, RDC &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a00792964db2b9c9b2bd784383cd46037">reduce</a> (const extent_gen&lt; NDIM &gt; &amp;ext, const Expr &amp;expr, const std::array&lt; size_t, NR &gt; &amp;reduce_dims)</td></tr>
<tr class="memdesc:a00792964db2b9c9b2bd784383cd46037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce sliced expression along specified dimensions. <br /></td></tr>
<tr class="separator:a00792964db2b9c9b2bd784383cd46037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe6c5fb7f45a204216fe8cc5a8077b8"><td class="memTemplParams" colspan="2"><a class="anchor" id="aabe6c5fb7f45a204216fe8cc5a8077b8"></a>
template&lt;class RDC , typename Expr , size_t NDIM, size_t NR&gt; </td></tr>
<tr class="memitem:aabe6c5fb7f45a204216fe8cc5a8077b8"><td class="memTemplItemLeft" align="right" valign="top">reduced_vector_view&lt; typename boost::proto::result_of::as_child&lt; const Expr, vector_domain &gt;::type, NDIM, NR, RDC &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#aabe6c5fb7f45a204216fe8cc5a8077b8">reduce</a> (const extent_gen&lt; NDIM &gt; &amp;ext, const Expr &amp;expr, const extent_gen&lt; NR &gt; &amp;reduce_dims)</td></tr>
<tr class="memdesc:aabe6c5fb7f45a204216fe8cc5a8077b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce sliced expression along specified dimensions. <br /></td></tr>
<tr class="separator:aabe6c5fb7f45a204216fe8cc5a8077b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb11762cd37576f01efe61862c39d032"><td class="memTemplParams" colspan="2"><a class="anchor" id="abb11762cd37576f01efe61862c39d032"></a>
template&lt;class RDC , typename Expr , size_t NDIM&gt; </td></tr>
<tr class="memitem:abb11762cd37576f01efe61862c39d032"><td class="memTemplItemLeft" align="right" valign="top">reduced_vector_view&lt; typename boost::proto::result_of::as_child&lt; const Expr, vector_domain &gt;::type, NDIM, 1, RDC &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#abb11762cd37576f01efe61862c39d032">reduce</a> (const extent_gen&lt; NDIM &gt; &amp;ext, const Expr &amp;expr, size_t reduce_dim)</td></tr>
<tr class="memdesc:abb11762cd37576f01efe61862c39d032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce sliced expression along specified dimension. <br /></td></tr>
<tr class="separator:abb11762cd37576f01efe61862c39d032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159a23f567b28d7d284fa0cd720e900a"><td class="memTemplParams" colspan="2">template&lt;class Expr , size_t Nout, size_t Nin&gt; </td></tr>
<tr class="memitem:a159a23f567b28d7d284fa0cd720e900a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a159a23f567b28d7d284fa0cd720e900a">reshape</a> (const Expr &amp;expr, const std::array&lt; size_t, Nout &gt; &amp;dst_dims, const std::array&lt; size_t, Nin &gt; &amp;src_dims) -&gt; decltype(<a class="el" href="namespacevex.html#a1d8048e3bb5185ab018e9d0a0649ef0b">vex::permutation</a>(detail::reshape_helper&lt; Nout, Nin &gt;(dst_dims, src_dims)())(expr))</td></tr>
<tr class="memdesc:a159a23f567b28d7d284fa0cd720e900a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshapes given expression.  <a href="#a159a23f567b28d7d284fa0cd720e900a">More...</a><br /></td></tr>
<tr class="separator:a159a23f567b28d7d284fa0cd720e900a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1cee04e928999c0ce6c069f8d1c901"><td class="memTemplParams" colspan="2">template&lt;class Expr , size_t Nout, size_t Nin&gt; </td></tr>
<tr class="memitem:ade1cee04e928999c0ce6c069f8d1c901"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ade1cee04e928999c0ce6c069f8d1c901">reshape</a> (const Expr &amp;expr, const extent_gen&lt; Nout &gt; &amp;dst_dims, const extent_gen&lt; Nin &gt; &amp;src_dims) -&gt; decltype(<a class="el" href="namespacevex.html#a1d8048e3bb5185ab018e9d0a0649ef0b">vex::permutation</a>(detail::reshape_helper&lt; Nout, Nin &gt;(dst_dims.dim, src_dims.dim)())(expr))</td></tr>
<tr class="memdesc:ade1cee04e928999c0ce6c069f8d1c901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshapes given expression.  <a href="#ade1cee04e928999c0ce6c069f8d1c901">More...</a><br /></td></tr>
<tr class="separator:ade1cee04e928999c0ce6c069f8d1c901"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac11898b99f6b77ea08316ac19f0e7e86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac11898b99f6b77ea08316ac19f0e7e86"></a>
const <a class="el" href="structvex_1_1range.html">range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#ac11898b99f6b77ea08316ac19f0e7e86">_</a></td></tr>
<tr class="memdesc:ac11898b99f6b77ea08316ac19f0e7e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placeholder for an unbounded range. <br /></td></tr>
<tr class="separator:ac11898b99f6b77ea08316ac19f0e7e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad713fa361047b676e76f2f2d3342dcdd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad713fa361047b676e76f2f2d3342dcdd"></a>
const extent_gen&lt; 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#ad713fa361047b676e76f2f2d3342dcdd">extents</a></td></tr>
<tr class="memdesc:ad713fa361047b676e76f2f2d3342dcdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper object for specifying slicer dimensions. <br /></td></tr>
<tr class="separator:ad713fa361047b676e76f2f2d3342dcdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c759e462ecb32cf236b5e5379da2f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73c759e462ecb32cf236b5e5379da2f1"></a>
const index_gen&lt; 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a73c759e462ecb32cf236b5e5379da2f1">indices</a></td></tr>
<tr class="memdesc:a73c759e462ecb32cf236b5e5379da2f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper object for specifying slicer shape. <br /></td></tr>
<tr class="separator:a73c759e462ecb32cf236b5e5379da2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Vector expression template library for OpenCL. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="acb82a55e98b3fb4747a1419c5517e951"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt;size_t, 2&gt;, sizeof...(Args) / 2&gt; vex::axes_pairs </td>
          <td>(</td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function for creating axes pairs. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> axes = <a class="code" href="namespacevex.html#acb82a55e98b3fb4747a1419c5517e951">axes_pairs</a>(a0, b0, a1, b1);</div>
<div class="line">assert(axes[0][0] == a0 &amp;&amp; axes[0][1] == b0);</div>
<div class="line">assert(axes[1][0] == a1 &amp;&amp; axes[1][1] == b1);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ae178cb03057d2aed93ab059c78631e8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator vex::copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy range from device vector to host vector. </p>
<p>Copy range from host vector to device vector. </p>

</div>
</div>
<a class="anchor" id="ac74a209f956b87b8dc289aad5498a25c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vex::device_spmv_perf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Weights device wrt to additive_operator performance. </p>
<p>Launches the following kernel on each device: </p><div class="fragment"><div class="line">y = A * x;</div>
</div><!-- fragment --><p> where x and y are vectors, and A is matrix for 3D Poisson problem in square domain. Each device gets portion of the vector proportional to the performance of this operation. </p>

<p>References <a class="el" href="classvex_1_1SpMat.html#a8d3b691e6259530d43489215104d9d4a">vex::SpMat&lt; val_t, col_t, idx_t &gt;::apply()</a>, <a class="el" href="classvex_1_1profiler.html#a62711181c6649461f6df957db5f22b0a">vex::profiler&lt; Clock &gt;::tic_cl()</a>, and <a class="el" href="classvex_1_1profiler.html#a0297c22109f3ede4376b33b85a0f3a1c">vex::profiler&lt; Clock &gt;::toc()</a>.</p>

</div>
</div>
<a class="anchor" id="a3688791c9b5aa7a26c7a63d9684b481c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vex::device_vector_perf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Weights device wrt to vector performance. </p>
<p>Returns device weight after simple bandwidth test.</p>
<p>Launches the following kernel on each device: </p><div class="fragment"><div class="line">a = b + c;</div>
</div><!-- fragment --><p> where a, b and c are device vectors. Each device gets portion of the vector proportional to the performance of this operation. </p>

<p>References <a class="el" href="classvex_1_1profiler.html#a62711181c6649461f6df957db5f22b0a">vex::profiler&lt; Clock &gt;::tic_cl()</a>, and <a class="el" href="classvex_1_1profiler.html#a0297c22109f3ede4376b33b85a0f3a1c">vex::profiler&lt; Clock &gt;::toc()</a>.</p>

</div>
</div>
<a class="anchor" id="acf35349b5accc05f96b291457f522acb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">elem_index vex::element_index </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When used in vector expression, returns current element index plus offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Element indices will start from this value. </td></tr>
    <tr><td class="paramname">length</td><td>Specify length of vector expression. This is only relevant when parent expression does not contain any vectors. See monte_carlo_pi test in tests/random.cpp for an example. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a629ee8dc1d5241fcfbc0289fbb8e7b0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vex::equal_weights </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns equal weight to each device. </p>
<p>This results in equal partitioning. </p>

</div>
</div>
<a class="anchor" id="a30a84e6989c6710c5a9fcc621b85cf00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvex_1_1Reductor.html">vex::Reductor</a>&lt;T, R&gt; vex::get_reductor </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an instance of vex::Reductor&lt;T,R&gt; </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aa04547c51b46e0005b37ad00493f7354"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename val_t , typename col_t , typename idx_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline_spmv&lt; <a class="el" href="classvex_1_1SpMat.html">SpMat</a>&lt;val_t, col_t, idx_t&gt;, <a class="el" href="classvex_1_1vector.html">vector</a>&lt;val_t&gt; &gt; vex::make_inline </td>
          <td>(</td>
          <td class="paramtype">const additive_operator&lt;<a class="el" href="classvex_1_1SpMat.html">SpMat</a>&lt; val_t, col_t, idx_t &gt;, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; val_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inlines a sparse matrix - vector product. </p>
<p>When applied to a matrix-vector product, the product becomes inlineable. That is, it may be used in any vector expression (not just additive expression). This is only possible in single-device contexts, so user has to guarantee that.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// Get maximum residual value:</span></div>
<div class="line">eps = sum( fabs(f - <a class="code" href="namespacevex.html#aa04547c51b46e0005b37ad00493f7354">vex::make_inline</a>(A * x)) );</div>
</div><!-- fragment --> 
<p>References <a class="el" href="namespacevex.html#a94c7748602834bd3b8b86762a0970a94">precondition()</a>.</p>

</div>
</div>
<a class="anchor" id="ae1e84dcac8995e5fbfb0cc2848d94297"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Tag, typename T , class Expr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">temporary&lt;T, Tag, Expr&gt; ::type vex::make_temp </td>
          <td>(</td>
          <td class="paramtype">const Expr &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create temporary to be reused in a vector expression. </p>
<p>The type of the temporary is explicitly specified. </p>

</div>
</div>
<a class="anchor" id="aad59a3b060765aaee879da333ac3a812"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Tag, class Expr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">temporary&lt;typename detail::return_type&lt;Expr&gt;::type, Tag, Expr&gt; vex::make_temp </td>
          <td>(</td>
          <td class="paramtype">const Expr &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create temporary to be reused in a vector expression. </p>
<p>The type of the temporary is automatically deduced from the supplied expression. </p>

</div>
</div>
<a class="anchor" id="a1d8048e3bb5185ab018e9d0a0649ef0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Expr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">expr_permutation&lt;Expr&gt; vex::permutation </td>
          <td>(</td>
          <td class="paramtype">const Expr &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns permutation functor which is based on an integral expression. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> reverse = <a class="code" href="namespacevex.html#a1d8048e3bb5185ab018e9d0a0649ef0b">vex::permutation</a>(N - 1 - <a class="code" href="namespacevex.html#acf35349b5accc05f96b291457f522acb">vex::element_index</a>());</div>
<div class="line">Y = reverse(X);</div>
</div><!-- fragment --> 
<p>Referenced by <a class="el" href="classvex_1_1SpMat.html#a8d3b691e6259530d43489215104d9d4a">vex::SpMat&lt; val_t, col_t, idx_t &gt;::apply()</a>, <a class="el" href="classvex_1_1gather.html#a0c7369858802c171620490893e42362b">vex::gather&lt; T &gt;::operator()()</a>, and <a class="el" href="namespacevex.html#a159a23f567b28d7d284fa0cd720e900a">reshape()</a>.</p>

</div>
</div>
<a class="anchor" id="a94c7748602834bd3b8b86762a0970a94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Condition , class Message &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vex::precondition </td>
          <td>(</td>
          <td class="paramtype">const Condition &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Message &amp;&#160;</td>
          <td class="paramname"><em>fail_message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check run-time condition. </p>
<p>Throws std::runtime_error if condition is false </p>

<p>Referenced by <a class="el" href="classvex_1_1Context.html#ad60f13674fc76037ff47507d4fe58086">vex::Context::Context()</a>, <a class="el" href="namespacevex.html#a4d36c4ddd6b769349ebb2c11badf2199">exclusive_scan()</a>, <a class="el" href="namespacevex.html#a8fc18f46eb80f11430bd7d1fd224e4df">inclusive_scan()</a>, <a class="el" href="namespacevex.html#aa04547c51b46e0005b37ad00493f7354">make_inline()</a>, <a class="el" href="structvex_1_1gslice.html#a5b3aad88352f5da13754544d83cbea82">vex::gslice&lt; NR &gt;::operator()()</a>, <a class="el" href="namespacevex.html#afca1d21b77d4ea7494aa032c9bb81db8">raw_pointer()</a>, and <a class="el" href="classvex_1_1vector.html#a9c2de310d894fca15385030ae906d545">vex::vector&lt; T &gt;::vector()</a>.</p>

</div>
</div>
<a class="anchor" id="a2f3700c5a3fd689cebd1c3301266b7ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vex::push_compile_options </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set global compute kernel compilation options for a given device. </p>
<p>This replaces any previously set options. To roll back, call <a class="el" href="namespacevex.html#ac07c402052137a80de67e1137f258341" title="Rolls back changes to compile options. ">pop_compile_options()</a>. </p>

</div>
</div>
<a class="anchor" id="aa16dc38863b68e8c2cd28a117044a3b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vex::push_program_header </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set global compute kernel header for a given device. </p>
<p>This replaces any previously set header. To roll back, call <a class="el" href="namespacevex.html#a1f5371f8233d7cfed97b68e3126e860e" title="Rolls back changes to compile options. ">pop_program_header()</a>. </p>

</div>
</div>
<a class="anchor" id="afca1d21b77d4ea7494aa032c9bb81db8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector_pointer&lt;T&gt; vex::raw_pointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast <a class="el" href="classvex_1_1vector.html" title="Device vector. ">vex::vector</a> to a raw pointer. </p>
<p>Useful when user wants to get a pointer to a vector instead of its current element inside a vector expression. Could be combined with calls to address_of/dereference operators or with user-defined functions iterating through the vector. See examples in tests/vector_pointer.cpp. </p>

<p>References <a class="el" href="classvex_1_1vector.html#a8877ef727c9a101d5a347f41c0ed6787">vex::vector&lt; T &gt;::nparts()</a>, and <a class="el" href="namespacevex.html#a94c7748602834bd3b8b86762a0970a94">precondition()</a>.</p>

</div>
</div>
<a class="anchor" id="a159a23f567b28d7d284fa0cd720e900a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Expr , size_t Nout, size_t Nin&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vex::reshape </td>
          <td>(</td>
          <td class="paramtype">const Expr &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; size_t, Nout &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; size_t, Nin &gt; &amp;&#160;</td>
          <td class="paramname"><em>src_dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespacevex.html#a1d8048e3bb5185ab018e9d0a0649ef0b">vex::permutation</a>(detail::reshape_helper&lt;Nout, Nin&gt;(dst_dims, src_dims)())(expr))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reshapes given expression. </p>
<p>Makes a multidimensional expression of dst_dims dimensions from input expression shaped as specified by src_dim. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Input expression </td></tr>
    <tr><td class="paramname">dst_dims</td><td>dimensions of the resulting expression. </td></tr>
    <tr><td class="paramname">src_dims</td><td>dimensions of the input expressions. Specified as positions in dst_dims.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// Matrix transposition:</span></div>
<div class="line"><span class="keyword">auto</span> B = <a class="code" href="namespacevex.html#a159a23f567b28d7d284fa0cd720e900a">reshape</a>(A, make_array&lt;size_t&gt;(n, m), <a class="code" href="namespacevex.html#acec621a57aaa5e1e17619376714b34c6">make_array</a>(1, 0));</div>
<div class="line"></div>
<div class="line"><span class="comment">// Expand 1D vector to a 2D matrix (by copying along redundant dimension):</span></div>
<div class="line"><span class="keyword">auto</span> A = <a class="code" href="namespacevex.html#a159a23f567b28d7d284fa0cd720e900a">reshape</a>(x, <a class="code" href="namespacevex.html#acec621a57aaa5e1e17619376714b34c6">make_array</a>(n, m), <a class="code" href="namespacevex.html#acec621a57aaa5e1e17619376714b34c6">make_array</a>(0));</div>
</div><!-- fragment --> 
<p>References <a class="el" href="namespacevex.html#a1d8048e3bb5185ab018e9d0a0649ef0b">permutation()</a>.</p>

</div>
</div>
<a class="anchor" id="ade1cee04e928999c0ce6c069f8d1c901"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Expr , size_t Nout, size_t Nin&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vex::reshape </td>
          <td>(</td>
          <td class="paramtype">const Expr &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const extent_gen&lt; Nout &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const extent_gen&lt; Nin &gt; &amp;&#160;</td>
          <td class="paramname"><em>src_dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespacevex.html#a1d8048e3bb5185ab018e9d0a0649ef0b">vex::permutation</a>(detail::reshape_helper&lt;Nout, Nin&gt;(dst_dims.dim, src_dims.dim)())(expr))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reshapes given expression. </p>
<p>Makes a multidimensional expression of dst_dims dimensions from input expression shaped as specified by src_dim. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Input expression </td></tr>
    <tr><td class="paramname">dst_dims</td><td>dimensions of the resulting expression. </td></tr>
    <tr><td class="paramname">src_dims</td><td>dimensions of the input expressions. Specified as positions in dst_dims.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// Matrix transposition:</span></div>
<div class="line"><span class="keyword">auto</span> B = <a class="code" href="namespacevex.html#a159a23f567b28d7d284fa0cd720e900a">reshape</a>(A, <a class="code" href="namespacevex.html#ad713fa361047b676e76f2f2d3342dcdd">extents</a>[n][m], <a class="code" href="namespacevex.html#ad713fa361047b676e76f2f2d3342dcdd">extents</a>[1][0]);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Expand 1D vector to a 2D matrix (by copying along redundant dimension):</span></div>
<div class="line"><span class="keyword">auto</span> A = <a class="code" href="namespacevex.html#a159a23f567b28d7d284fa0cd720e900a">reshape</a>(x, <a class="code" href="namespacevex.html#ad713fa361047b676e76f2f2d3342dcdd">extents</a>[n][m], <a class="code" href="namespacevex.html#ad713fa361047b676e76f2f2d3342dcdd">extents</a>[0]);</div>
</div><!-- fragment --> 
<p>References <a class="el" href="namespacevex.html#a1d8048e3bb5185ab018e9d0a0649ef0b">permutation()</a>.</p>

</div>
</div>
<a class="anchor" id="a7740d79c763aba34de005e957fb27db5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vex::set_partitioning </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; double(const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;) &gt;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partitioning scheme for vectors and matrices. </p>
<p>Should be set once before any object of vector or matrix type is declared. Otherwise default parttioning function (partition_by_vector_perf) is selected. </p>

</div>
</div>
<a class="anchor" id="a84b2ded8868f71bc74e4e270d2a8dae9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Comp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vex::sort </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comp&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the vector into ascending order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>comparison function. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="namespacevex.html#a60bc72755a950140b17b769133e9147a">sort()</a>.</p>

</div>
</div>
<a class="anchor" id="a6c0d7aa078f1ae079e3a06708d9b84b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class Comp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vex::sort_by_key </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comp&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the elements in keys and values into ascending key order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>comparison function. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="namespacevex.html#a29b043fcc5a4892ef36b5b6b8a218f38">sort_by_key()</a>.</p>

</div>
</div>
<a class="anchor" id="ab46ae67da517dca8015475e021e7ab27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Tag, class Expr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vex::tag </td>
          <td>(</td>
          <td class="paramtype">const Expr &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> -&gt; const tagged_terminal&lt;
                        Tag,
                        decltype(boost::proto::as_child&lt;vector_domain&gt;(expr))
                &gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tags terminal with a unique (in a single expression) tag. </p>
<p>By tagging terminals user guarantees that the terminals with same tags actually refer to the same data. VexCL is able to use this information in order to reduce number of kernel parameters and unnecessary global memory I/O operations.</p>
<p>Example: </p><div class="fragment"><div class="line">s = sum(tag&lt;1&gt;(x) * tag&lt;1&gt;(x) + tag&lt;2&gt;(y) * tag&lt;2&gt;(y));</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ab7ed95396644bcef1aff9a0cac89e69a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Expr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">expression_tuple&lt; std::tuple&lt;const Expr&amp;...&gt; &gt; vex::tie </td>
          <td>(</td>
          <td class="paramtype">const Expr &amp;...&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ties several vector expressions into writeable tuple. </p>
<p>The following example results in a single kernel: </p><div class="fragment"><div class="line"><a class="code" href="classvex_1_1vector.html">vex::vector&lt;double&gt;</a> x(ctx, 1024);</div>
<div class="line"><a class="code" href="classvex_1_1vector.html">vex::vector&lt;double&gt;</a> y(ctx, 1024);</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacevex.html#ab7ed95396644bcef1aff9a0cac89e69a">vex::tie</a>(x,y) = <a class="code" href="namespacevex.html#ab7ed95396644bcef1aff9a0cac89e69a">std::tie</a>( x + y, y - x );</div>
</div><!-- fragment --><p> This is functionally equivalent to </p><div class="fragment"><div class="line">tmp_x = x + y;</div>
<div class="line">tmp_y = y - x;</div>
<div class="line">x = tmp_x;</div>
<div class="line">y = tmp_y;</div>
</div><!-- fragment --><p> but does not use temporaries and is more efficient. </p>

<p>Referenced by <a class="el" href="classvex_1_1Context.html#ad60f13674fc76037ff47507d4fe58086">vex::Context::Context()</a>, and <a class="el" href="classvex_1_1mba.html#a5660107fe6178eec3173b39288583494">vex::mba&lt; NDIM, real &gt;::operator()()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
